library("MaxPro")

#####################################################
# Functions
#####################################################
scale_from_0_1 = function(x, rescalings) {
  # Given a matrix x of real numbers,
  # rescale the entries.  Assume that
  # entries in the same column of x
  # should be rescaled in the same way.
  #
  # Args:
  #   x: numeric. matrix with entries in the
  #       interval [0, 1].
  #   rescalings: matrix. It is required that
  #       NROW(rescalings) == NCOL(x).  Each row of 
  #       rescalings should contain a vector
  #       with two entries. The 1st entry
  #       should be the min and the 2nd entry
  #       should be the max for the rescaling
  #       of the column in x corresponding to 
  #       that row.
  #   
  # Returns:
  #   matrix of the same dimensions as x.
  num_x_rows = NROW(x)
  num_x_cols = NCOL(x)
  # To be filled in later . . . .
  rescaled_x = matrix(
    data = numeric(length = num_x_rows * num_x_cols), 
    nrow = num_x_rows, 
    ncol = num_x_cols, 
    byrow = TRUE
  )
  
  # Rescale each column of x.
  for (j in seq_len(num_x_cols)) {
    rescaled_x[, j] = x[, j]*(rescalings[j, 2] - rescalings[j, 1]) + rescalings[j, 1]
  }
  
  return(rescaled_x)
}

scale_to_0_1 = function(x, rescalings) {
  # Given a matrix x of real numbers,
  # rescale the entries.  Assume that
  # entries in the same column of x
  # should be rescaled in the same way.
  #
  # Args:
  #   x: numeric. matrix.
  #   rescalings: matrix. It is required that
  #       NROW(rescalings) == NCOL(x).  Each row of 
  #       rescalings should contain a vector
  #       with two entries. The 1st entry
  #       should be the min and the 2nd entry
  #       should be the max for the rescaling
  #       of the column in x corresponding to 
  #       that row.
  #   
  # Returns:
  #   matrix of the same dimensions as x.
  num_x_rows = NROW(x)
  num_x_cols = NCOL(x)
  # To be filled in later . . . .
  rescaled_x = matrix(
    data = numeric(length = num_x_rows * num_x_cols), 
    nrow = num_x_rows, 
    ncol = num_x_cols, 
    byrow = TRUE
  )
  
  # Rescale each column of x.
  for (j in seq_len(num_x_cols)) {
    rescaled_x[, j] = (x[, j] - rescalings[j, 1])/(rescalings[j, 2] - rescalings[j, 1])
  }
  
  return(rescaled_x)
}

generate_max_pro_design = function(n, p_cont, rescalings) {
  # Generate a MaxPro design with n design points
  # in the space [0, 1]^{p_cont}.
  #
  # Args:
  #   n: numeric(1).
  #   p_cont: numeric(1).
  #   rescalings: matrix. It is required that
  #       NROW(rescalings) == p_cont.  Each row of 
  #       rescalings should contain a vector
  #       with two entries. The 1st entry
  #       should be the min and the 2nd entry
  #       should be the max for the rescaling
  #       of the factor corresponding to 
  #       that row.
  #
  # Returns:
  #   matrix of scaled design 
  
  # The authors of MaxPro recommend that the initial design 
  # used in the MaxPro fucntion is generated by the 
  # MaxProLHD function.
  d_obj = MaxPro::MaxProLHD(
    n = n,
    p = p_cont,
    s = 2,
    itermax = 500,
    total_iter = 1e+05
  )
  
  d = d_obj[["Design"]]
  
  # Improve the design further.
  print("Running MaxPro . . . .")
  d_obj = MaxPro::MaxPro(
    InitialDesign = d,
    s = 2,
    iteration = 10
  )
  
  d = d_obj[["Design"]]
  
  # Rescale design to check constraints.
  d = scale_from_0_1(
    x = d,
    rescalings = rescalings
  )
  
  # Rescale back to 0-1
  d = scale_to_0_1(
    x = d,
    rescalings = rescalings
  )
  
  # Generate a candidate design meeting the constraints
  # that we can pull from.
  c = MaxPro::CandPoints(N = 10000, p_cont = p_cont)
  
  # Scale
  d = scale_from_0_1(
    x = d,
    rescalings = rescalings
  )
  
  # Permute rows randomly
  d = d[sample.int(NROW(d)), ]
  
  return(d)
}

######################################################################
# Main code
######################################################################
N = 10
rescalings = matrix(
  data = c(
    5e-05, 1e-03,
    1e-06, 1e-02
  ),
  nrow = 2,
  ncol = 2,
  byrow = TRUE
)
d = generate_max_pro_design(
  n = N,
  p_cont = 2,
  rescalings = rescalings
)

d_with_names = data.frame(d)
colnames(d_with_names) = c("learning_rate", "weight_decay")
print(d_with_names)
plot(d_with_names[["learning_rate"]], d_with_names[["weight_decay"]], xlab = "Learning Rate", ylab = "Weight Decay", main = "Hyperparameter Experimental Design")
